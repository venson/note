---
typora-copy-images-to: pic
---

# Chaper 4 逻辑架构

## 1. 逻辑架构剖析

### 1.1 服务器处理客户端请求

那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：

![image-20220207211540349](./pic/image-20220207211540349.png)

![image-20220207211644130](./pic/image-20220207211644130.png)

### 1.2 Connectors

### 1.3 第1层：连接层

系统（客户端）访问 `MySQL` 服务器前，做的第一件事就是建立 `TCP` 连接。
经过三次握手建立连接成功后，` MySQL` 服务器对 `TCP` 传输过来的账号密码做身份认证、权限获取。

- **用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行**
- **用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限**

思考问题

一个系统只会和MySQL服务器建立一个连接吗? 只能有一个系统和MySQL建立连接吗?

多个系统可以和MySQL服务器建立连接, 每个系统建立的连接肯定不止一个. 所以, 为了解决TCP无限创建和TCP频繁小会带来的资源耗尽,性能下降问题. MySQL服务器里有专门的TCP连接池限制连接数, 采用长连接模式复用TCP连接, 解决上述问题.



![image-20220207213301854](./pic/image-20220207213301854.png)

`TCP` 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。



这些内容我们都归纳到MySQL的连接管理组建中. 

所以连接管理的职责是负责认证, 管理连接, 获取权限信息. 



### 1.4 第2层：服务层

第二成架构主要完成大多数的核心服务功能, 如SQL接口, 并完成缓存的查询, SQL的分析和优化及部分内置函数的执行. 所有跨存储引擎的功能也在这一层实现, 如 过程, 函数等. 

在该层, 服务器会`解析查询`并创建相应的内部`解析树`, 并对其完成相应的优化: 如确定查询表的顺序, 是否利用索引等, 最后生成相应的执行操作. 

如果是SELECT语句,服务器还会`查询内部的缓存`. 如果缓存空间足够大, 这样在解决大量读操作的环境中能够很好的提升系统的性能. 

- **SQL Interface: SQL接口**

  - 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ... FROM就是调用SQL Interface
  - MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口

- **Parser: 解析器**

  - 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。
  - 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 `验证该客户端是否具有执行该查询的权限 `。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。

- Optimizer: 查询优化器

  - SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个`执行计划 `。

  - 这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

  - 它使用“ `选取-投影-连接 `”策略进行查询。例如：

    ```sql
    SELECT id,name FROM student WHERE gender = '女';
    ```

    这个SELECT查询先根据WHERE语句进行`选取` ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 `投影` ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。

- Caches & Buffers： 查询缓存组件

  - MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。

  - 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。

  - 这个查询缓存可以在 不同客户端之间共享 。

  - 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 `MySQL 8.0中删除` 。

    ```
    小故事：
    如果我问你9+8×16-3×2×17的值是多少，你可能会用计算器去算一下，最终结果35。如果再问你一遍9+8×16-
    3×2×17的值是多少，你还用再傻呵呵的再算一遍吗？我们刚刚已经算过了，直接说答案就好了。
    ```

### 1.5 第3层：引擎层

和其他数据库相比, MySQL有点与众不同, 他的架构可以在多种不同场景中应用并发挥良好作用, 主要体现在存储引擎的架构上. 插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离. 这汇总架构可以根据业务的需求和实际需要选择合适的存储引擎, 同时开源的MySQL还允许开发人员设置自己的存储引擎. 

这种搞笑的模块化架构为那些希望专门针对特定应用程序需求(如数据仓库, 事务处理和高可用性情况) 的人提供了巨大的好处, 同时享受使用一组独立于任何接口和服务的优势存储引擎. 

插件式存储引擎层（ Storage Engines），**真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作**，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。
MySQL 8.0.28默认支持的存储引擎如下：

![image-20220207212456624](./pic/image-20220207212456624.png)

### 1.6 存储层

所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存
在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设
备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用
DAS、NAS、SAN等各种存储系统。

### 1.7 小结

MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：

![image-20220207222851807](./pic/image-20220207222851807.png)



## 2. SQL执行流程

![image-20220207223054021](./pic/image-20220207223054021.png)

MySQL的查询流程：

1. 查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没
有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃
了这个功能。

大多数情况查询缓存就是个鸡肋，为什么呢？

```sql
SELECT employee_id,last_name FROM employees WHERE employee_id = 101;
```

查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的 `鲁棒性大大降低` ，只有 `相同的查询操作才会命中查询缓存` 。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 `查询缓存命中率不高` 。
同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！

此外，既然是缓存，那就有它 `缓存失效的时候` 。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于 `更新压力大的数据库` 来说，查询缓存的命中率会非常低。

**总之, 因为查询缓存往往弊大于利, 查询缓存的失效非常频繁. **

一般建议大家在静态表里使用查询缓存, 什么是静态表, 就是一般极少更新的表. 比如, 一个系统配置表, 字典表, 这张表上的查询才适合使用查询缓存. 好在MySQL也提供这种`按需使用`的方式. 你可以将my.cnf参数query_cache_type设置成DEMEND, 代表当SQL语句中有SQL_CACHE关键词时才使用缓存. 

```sql
query_cache_type=2 # 0 OFF, 1 ON, 2 DEMAND
```

```sql
SELECT SQL_CACHE * FROM test where id=5;

```



2. 解析器：在解析器中对 SQL 语句进行语法分析、语义分析。

![image-20220207225128452](./pic/image-20220207225128452.png)

分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。

接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否 满足 MySQL 语法 。

```sql
select department_id,job_id,avg(salary) from employees group by department_id;
```

如果SQL语句正确，则会生成一个这样的语法树：![image-20220207225945527](./pic/image-20220207225945527.png)

![image-20220207230053977](./pic/image-20220207230053977.png)

至此解析器的工作任务圆满结束, 进入优化器. 

3. 优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。

  经过了解析器, MySQL就知道你要做什么了, 在开始执行之前, 还要经过优化器的处理. ** 一条查询可以有很多种执行方式, 最后都返回相同的结果. 优化器的左右就是找到其中最好的执行计划. 

  ![image-20220207230434437](./pic/image-20220207230434437.png)

举例：如下语句是执行两个表的 join：

```sql
select * from test1 join test2 using(ID)
where test1.name='zhangwei' and test2.name='mysql高级课程';
```

```sql
方案1：可以先从表 test1 里面取出 name='zhangwei'的记录的 ID 值，再根据 ID 值关联到表 test2，再判
断 test2 里面 name的值是否等于 'mysql高级课程'。
方案2：可以先从表 test2 里面取出 name='mysql高级课程' 的记录的 ID 值，再根据 ID 值关联到 test1，
再判断 test1 里面 name的值是否等于 zhangwei。
这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化
器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。
如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。
```

在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。

逻辑查询优化就是通过改变SQL语句的内容来时的SQL查询更高效, 同时为物理查询优化提供更多的候选执行计划. 同行藏采用的方式是对SQL语句进行等价变换, 对查询进行重写, 而查询重写的数学基础就是关系代数. 对条件表达式进行等价谓词重写, 条件简化, 对试图进行重写, 对子查询进行优化, 对连接语义进行了外连接消除, 嵌套连接消除等. 

物理查询优化是基于关系代数进行的查询重写, 而关系代数的每一步都对应着物理计算, 而这些物理计算往往存在多种算法, 因此需要计算各种物理路径代价, 从中选择代价最小的作为执行计划, 而在这个阶段里, 对于单表和多表的连接操作, 需要高效的使用索引, 提升查询效率. 

4. 执行器：
截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。

![image-20220207231415315](./pic/image-20220207231415315.png)

在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL
查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。

```sql
select * from test where id=1;
```

如果有权限, 就打开表继续执行. 打开表的时候, 执行器就会根据表的引擎定义, 调用存储引擎API对表进行读写. 存储引擎API只是抽象的借口,下面还有存储引擎层, 具体实现还要看表选择的存储引擎. 

![image-20220207231731125](./pic/image-20220207231731125.png)

比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：

```
调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；
调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
```

至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。
SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。

![image-20220207231840322](./pic/image-20220207231840322.png)

# Chapter 5 存储引擎

## 1. 查看存储引擎

```sql
SHOW engines;
```

![image-20220208105219570](./pic/image-20220208105219571.png)

```sql
SHOW engines \G;
```

```sql
mysql> mysql> show engines \G
*************************** 1. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 8. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
9 rows in set (0.00 sec)
```

## 2. 设置默认的存储引擎

- 查看默认的存储引擎:

  ```sql
  SHOW variables LIKE '%storage_engine%';
  SELECT @@default_storage_engine;
  ```

  ![image-20220208105801037](pic/image-20220208105801037.png)

- 修改默认的存储引擎

  如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行:

```sql
SET DEFAULT_STORAGE_ENGINE=MyISAM;
```

或者修改 my.cnf 文件:

```bash
default-storage-engine=MyISAM
# 重启服务
systemctl restart mysqld.service
```

## 3. 设置表的存储引擎

### 3.1 创建表时指定存储引擎

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎InnoDB 。如果我们想显式的指定一下表的存储引擎，那可以这么写:

```sql
CREATE TABLE 表名( 
  建表语句;
) ENGINE = 存储引擎名称;
```

### 3.2 修改表的存储引擎

如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎:

```sql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

比如我们修改一下 engine_demo_table 表的存储引擎:

```sql
mysql> ALTER TABLE engine_demo_table ENGINE = InnoDB;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

这时我们再查看一下 engine_demo_table 的表结构:

```sql
mysql> SHOW CREATE TABLE engine_demo_table\G
*************************** 1. row ***************************
       Table: engine_demo_table
Create Table: CREATE TABLE `engine_demo_table` (
  `i` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.01 sec)
```

## 4. 引擎介绍

### 4.1 InnoDB 引擎:具备外键支持功能的事务存储引擎

- MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。
-  InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。
- 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。
- **除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑**InnoDB**引擎。**
- 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）
  - 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）
  - 表名.ibd 存储数据和索引

- InnoDB是 为处理巨大数据量的最大性能设计 。
  - 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。

- 对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。

- MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。

### 4.2 MyISAM **引擎：主要的非事务处理存储引擎** 

- MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 

- 5.5之前默认的存储引擎

- 优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用

- 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高

- 数据文件结构：（在《第02章_MySQL数据目录》章节已讲）

  - 表名.frm 存储表结构

  - 表名.MYD 存储数据 (MYData)

  - 表名.MYI 存储索引 (MYIndex)

- 应用场景：只读应用或者以读为主的业务



# Chapter 6 索引的数据结构

## 1. 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构, 就好比一本教科书的目录部分, 通过目录中找到对应文章的页码, 便可快速定位到需要的文章, MySQL中也是一样的道理, 进行数据查找时, 首先查看查询条件是否命中某条索引,符合则通过索引查找相关数据, 如果不符合则需要全表扫描, 即需要一条一条的查找记录, 直到找到与条件符合的记录. 

![image-20220208112826391](pic/image-20220208112826391.png)

如上图所示, 数据库没有索引的情况下, 数据分布在磁盘的不同的位置上面, 读取数据时, 摆臂需要前后摆动查找数据, 非常消耗时间. 

如果数据顺序摆放, 那么也需要从1到6行按顺序读取, 这样就相当于进行了6次IO操作, 依旧非常耗时.

 如果我们不借助任何索引结构帮助我们快速定位数据的话, 我们查找col2 = 89这条记录, 就要逐行去查找, 比较. 从col2 =34 开始,进行比较, 发现不是, 继续下一行. 我们当前的表只有不到10行数据, 但如果表很大的话, 就意味着要进行很多很多次磁盘I/O才能找到. 

现在要查找col2 = 89这条记录. CPU必须先去磁盘查找这条记录, 找到之后加载到内存, 在对数据进行处理. 这个过程最好时间的就是磁盘I/O(设计磁盘的旋转时间/速度较快, 刺头的寻道时间/ 速度慢费时)

假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示

# ![image-20220208114141742](pic/image-20220208114141742.png)

对字段col2 添加了索引,就相当于在磁盘上为col2 维护了一个索引的数据结构, 即这个二叉搜索树. 

二叉搜索树的每个节点存储的是(K,V)结构, key是col2, value是该key所在行的文件指针(地址), 比如:该二叉手所属的节点就是:(34, 0x07). 

现在对col2 添加了索引, 这时再去查找col2=89这条记录时:

1. 先去查找该二叉搜索树(二叉树的遍历查找). 读34到内存, 89>34; 
2. 则继续右侧数据, 读89到内存 89==89; 
3. 找到数据返回, 找到之后就根据当前节点的value快速定位到要查找的记录对应的地址.

我们可以发现, 只要查找两次就可以定位到记录的地址, 查询速度就提高了. 

这就是我们为什么要建索引, 目的就是为了减少磁盘I/O的次数, 加快查询速率. 

### 2. 索引及其优缺点

### 2.1 索引概述

MySQL官方对索引的定义为：**索引（**Index**）是帮助**MySQL**高效获取数据的数据结构**。

**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 `高级查找算法 `。 

索引是在存储引擎中实现的 因此每种存储引擎的索引不一定完全相同, 并且每种存储引擎不一定支持所有索引类型. 同时, 存储引擎可以定义每个表的最大索引树和最大索引长度. 所有存储引擎迟滞每个表至少16个索引, 总索引长度至少为256哥字节, 有些存储引擎支持更过的索引树和更大的索引长度. 

### 2.2 优点 

1. 类似大学图书馆建书目索引，提高数据检索的效率，降低 `数据库的IO成本 `，这也是创建索引最主要的原因。 
2. 通过创建唯一索引，可以保证数据库表中每一行 `数据的唯一性` 。
3. 在实现数据的参考完整性方面，可以 `加速表和表之间的连接` 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著 `减少查询中分组和排序的时间` ，降低了CPU的消耗。

### 2.3 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面： 

1. 创建索引和维护索引要 `耗费时间` ，并且随着数据量的增加，所耗费的时间也会增加。
2. 索引需要占 `磁盘空间` ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，` 存储在磁盘上` ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
3. 虽然索引大大提高了查询速度，同时却会 `降低更新表的速度` 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示:
>
> 索引可以提高查询的速度, 但是会影响插入记录的速度. 这种情况下, 最好的办法是删除表中的索引, 然后插入数据, 在数据插入完全后再创建索引. 

## 3. InnoDB**中索引的推演**

### 3.1 索引之前的查找

先来看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 
```

1. **在一个页中的查找** 

   假设目前表中的记录比较少, 所有记录都可以放在一个页中(一页空间16KB), 在查找记录的时候可以根据搜索条件的不同分为两种情况:

   - 以主键为搜索条件

     可以在页目录中使用二分法快速定位到对应的槽, 然后再遍历该槽对应分组中的记录即可快速找到制定的记录.

   - 已其他列为搜索条件

     因为在数据页中并没有对非主键建立所谓的页目录, 所以我们无法通过二分法快速定位相应的槽. 这种情况下只能从最小记录开始依次遍历单链表中的每条记录, 然后对比记录是不是符合搜索条件. 很显然,这种查找的效率是非常低的. 

   

2. **在很多页中查找**

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 `从第一个页` 沿着 `双向链表` 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 `超级耗时` 的。如果一个表有一亿条记录呢？此时 `索引` 应运而生。

### 3.2 设计索引

建一个表

```sql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```

这个新建的 `index_demo` 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 `Compact` 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：

![image-20220208130351114](pic/image-20220208130351114.png)

我们只在示意图里展示记录的这几个部分 

- record_type:记录头信息的一项属性,表示记录的类型 , 0 表示普通记录、2 表示最小记录 、3 表示最大记录、1 暂时还没用用过, 下面讲。

- next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。

- 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 

- 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

  将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

  ![image-20220208135251047](pic/image-20220208135251047.png)

把一些记录放在页里的示意图就是:

![image-20220208135339055](pic/image-20220208135339055.png)

## 1. 一个简单的索引设计方案

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 想快速的定位到需要查找的记录在哪些数据页 中该咋办？我们可以为快速定位记录所在的数据页而 建 立一个目录 ，建这个目录必须完成下边这些事：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

  假设: 每个数据也最多能存放3条记录(实际一个数据页非常大, 可以存放好多记录, 我们像index_demo表出入3条记录), 主键递增的顺序.

  ```sql
  mysql > INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5,3,'y');
  Query OK, 3 rows affected (0.01 sec)
  Records: 3 Duplicates: 0  Warnings: 0
  ```

![](pic/image-20220208143136612.png)

从图中可以看出来, index_demo表中的3条记录都被插入到编号为10的数据页中, 此时我们再来插入一条记录

```sql
mysql> INSERT INTO index_demo VALUES(4,4,'a');
```

因为页10最多只能放3条记录, 所以我们需要再分配一个新页. 



![image-20220208143114476](pic/image-20220208143114476.png)

注意, 新分配的数据页编号可能并不是连续的, 他们只是通过维护者上一个页和下一个页的编号二建立了链表关系. 另外, 页10中用户记录最大的主键值是5, 而页28中有一条记录的主键值是4, 因为5>4, 所以这里就不符合下一个数据页中用户记录的主键值必须大于上一个页面中用户记录的主键值的要求, 所以在插入主键值为4的记录的时候需要在伴随一次记录移动. 也就是吧主键值为5的记录移动到页28中, 然后再把主键值为4的记录插入到页10中, 这个过程的示意图如下. 

![image-20220208143811860](pic/image-20220208143811860.png)

这个过程表明了在对页中的记录进行增删改操作的过程中, 我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立: 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值. 这个过程我们成为分页裂.(page split ?)

- 给所有的页建立一个目录项.

  由于数据页的编号可能是不连续的, 所以在想index_demo表中插入许多条记录后, 可能是这样的效果

![image-20220208144706015](pic/image-20220208144706015.png)

因为这些16KB的页在物理存储上是不连续的, 所以如果想从这么多页中根据主键值快速定位某些记录所在的页, 我们需要给他们做个目录, 每个页对应一个目录项, 每个项目包括下边两个部分. 

1. 页的用户记录中最小的主键值, 我们用key来表示.
2. 页号, 我们用page_no表示. 

以 `页28` 为例，它对应 `目录项2` ，这个目录项中包含着该页的页号 `28` 以及该页中用户记录的最小主键值 `5` 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

1. 先从目录项中根据 `二分法` 快速确定出主键值为 `20` 的记录在 `目录项3` 中（因为 `12 < 20 < 209` ），它对应的页是 `页9` 。 

2. 再根据前边说的在页中查找记录的方式去 `页9` 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 `索引` 。 

### 2. InnoDB**中的索引方案** 

1. 迭代1次：目录项纪录的页

上边称为一个简易的索引方案, 是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储, 但是这样做就有几个问题:

- InnoDB是使用页来作为管理存储空间的基本单位, 最多保证16KB的连续存储空间, 而随着表中记录数量的增多, 需要非常大的连续存储空间次啊能吧所有的目录项都放下, 而这对记录数量非常多的表是不现实的. 
- 我们时常会对记录进行增删, 假设我们把原页28中的记录全部删除, 那意味着目录项2也就没有存在的必要了, 这就需要把目录项2后的目录项都向前移动一下, 这样牵一发而动全身的操作效率很差. 

所以, 我们需要一种可以灵活管理所有目录项的方式, 我们发现目录项其实长的与我们的用户记录差不多, 只不过目录项中的两列是主键和页号而已, 为了和用户记录做一下区分, 我们把这些用来表示目录项的记录称为目录项记录. 那InnoDB怎么区分一条记录是普通的用户记录还是目录项记录呢? 使用记录都心系里的record_type属性, 他的各个取值代表的意思如下:

- 0: 普通的用户记录
- 1: 目录项记录
- 2: 最小记录
- 3: 最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![image-20220208145620737](pic/image-20220208145620737.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录和普通的 `用户记录` 的**不同点**： 

- `目录项记录` 的 `record_type` 值是1，而 `普通用户记录` 的 `record_type` 值是0。

- 目录项记录只有 主键值和页的编号 两个列，而普通的用户记录的列是用户自己定义的，可能包含 很多列 ，另外还有InnoDB自己添加的隐藏列。

- 了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

**相同点：**两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 二分法 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储 `目录项记录` 的页，也就是页30中通过 `二分法` 快速定位到对应目录项，因为 `12 < 20 < 209` ，所以定位到对应的记录所在的页就是页9。 

2. 再到存储用户记录的页9中根据 `二分法`快速定位到主键值为 `20` 的用户记录。

2. 迭代2次：多个目录项纪录的页

虽然说目录项记录中只存储主键值和对应的页号, 比用户记录需要的存储空间小很多, 但是不论怎么说一个页只有16KB大小, 能存放的目录项记录也是有限的, 那如果表中的数据太多, 以至于一个数据页不足以存放所有的目录项记录, 如何处理呢?



我们假设一个存储目录项记录的页最多存放4条目录项记录, 所以如果此时我们再向上图中插入一条主键值为320的用户记录的话, 那就需要分配一个新的存储目录项记录的页:

![image-20220208152340610](pic/image-20220208152340610.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了 `页31` 。

- 因为原先存储目录项记录的 `页30的容量已满` （我们前边假设只能存储4条目录项记录），所以不得不需要一个新的 `页32` 来存放 `页31` 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1. 确定 `目录项记录页`

我们现在的存储目录项记录的页有两个，即 `页30` 和 `页32` ，又因为页30表示的目录项的主键值的范围是 `[1, 320)` ，页32表示的目录项的主键值不小于 `320` ，所以主键值为 20 的记录对应的目录项记录在 `页30` 中。

2. 通过目录项记录页 `确定用户记录真实所在的页` 。

在一个存储 `目录项记录` 的页中通过主键值定位一条目录项记录的方式说过了。

3. 在真实存储用户记录的页中定位到具体的记录。

3. 迭代3次: 目录项记录页的目录页

   问题来了, 在这个查询步骤的第一步中我们需要定位存储目录项记录的页, 但这些`页是不连续的`, 如果我们表中的数据非常多则会`产生很多存储目录项记录的页`, 那我们怎么根据主键值快速定位一个存储目录项记录的页呢?那就为这些存储目录项记录的页在生成一个`更高级的目录`, 就像是个多级目录一样, `大目录里嵌套小目录`, 小目录里次啊是实际的数据, 所以现在各个页的示意图就是这个样子:

   ![image-20220208152729898](pic/image-20220208152729898.png)

如图，我们生成了一个存储更高级目录项的 `页33 `，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 `[1, 320)` 之间，则到页30中查找更详细的目录项记录，如果主键值 `不小于320` 的话，就到页32中查找更详细的目录项记录。

随着表中记录的增加, 这个目录的层级会继续增加, 如果简化一下, 那么我们我可以用下面这个图来描述他:

![image-20220208153426174](pic/image-20220208153426174.png)

这个数据结构，它的名称是 `B+树 `。 

4. B+Tree

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 `最多存放3条记录` ，存放目录项记录的页 `最多存放4条记录` 。其实真实环境中一个页存放的记录数量是非常大的，`假设`所有存放用户记录的叶子节点代表的数据页可以存放 `100条用户记录` ，所有存放目录项记录的内节点代表的数据页可以存放` 1000条目录项记录` ，那么：

- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
- 如果B+树有2层，最多能存放 `1000×100=10,0000` 条记录。

- 如果B+树有3层，最多能存放 `1000×1000×100=1,0000,0000` 条记录。

- 如果B+树有4层，最多能存放 `1000×1000×1000×100=1000,0000,0000 `条记录。相当多的记录！！！

你的表里能存放 `100000000000` 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 `Page Directory` （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。

### 3.3 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。

1. 聚簇索引

聚簇索引并不是一种单独的索引类型, 而是一种数据存储方式(所有的用户记录都存储在了叶子节点Leaf node), 也就是所谓的索引即数据,数据即索引.

> 术语聚簇 表示数据行和相邻的键值聚簇的的存储在一起

**特点：**

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
   - 各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
   - 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。 

2. B+树的 `叶子节点` 存储的是完整的用户记录。

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

   

我们把具有这两种特性的B+树称为`聚簇索引`, 所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处. 这种聚簇索引并不需要我们在MySQL语句中显示的使用`INDEX`语句去创建, `InnoDB`存储引擎会`自动`的为我们创建聚簇索引. 

**优点：**

- `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快

- 聚簇索引对于主键的 `排序查找` 和` 范围查找` 速度非常快

- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 `节省了大量的io操作` 。

**缺点：**

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的**ID**列为主键**

- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**

- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据

**限制:**

- 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引, 而MyISAM并不支持聚簇索引

- 对于数据物理存储排序方式只能有一种, 所以每个MySQL的`表只能有一个聚簇索引`. 一般情况下就是该表的主键. 

- 如果没有定义主键, InnoDB会选择`非空的唯一索引`代替. 如果没有这样的索引, InnoDB会隐式的定义一个主键来作为聚簇索引. 

- 为了允许利用聚簇索引的聚簇的特性, 所以InnoDB表的主键尽量`选用有序的序列id`, 而不建议用无序的id, 比如UUID, MD5, HASH,字符串作为主键无法保证数据的顺序增长. 

  

2. 二级索引（辅助索引、非聚簇索引）

   上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用, 因为B+树中的数据都是按照主键进行排序的, 那如果我们像以别的列作为搜索条件怎么办呢? 肯定不能是从头到位沿着链表遍历记录一遍.

   答案: 我们可以`多建几个B+树`, 不同的B+树中的数据采用不用的排序规则. 比方说我们用`c2`列的大小作为数据页, 页中记录的排序, 再建一棵B+树, 效果如下图所示:

   ![image-20220208160723086](pic/image-20220208160723086.png)

这个B+树与上边介绍的聚簇索引有几处不同:

- 使用记录c2列的大小进行记录和页的排序, 这包括三个方面的含义:
  - 业内的记录是按照c2列的大小顺序排成一个单向链表
  - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表
  - 存放用户记录的页分为不同层次,在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表
- B+树的叶子节点存储的并不是完整的用户记录, 而知识c2列+主键这两个列的值
- 目录项记录中不再是主键+页号的搭配, 而变成了c2列+页号的搭配. 

所以如果我们现在想通过c2列的值查找某些记录的话, 就可以使用我们刚刚建好的这个B+树了, 以查找c2列的值为4的记录为例, 查找过程如下:

1. 确定目录项记录页

   根据根页面, 也就是页44, 可以快速定位到目录记录所在的页为页43(因为2<4<9).

2. 根据目录项记录页确定用户记录真实所在的页.

   在页42中可以快速定位到实际存储用户记录的页, 但是由于c2列并没有唯一性约束, 所以c2列值为4的记录可能分布在多个数据页中, 又因为2<4<=4, 所以确定世纪存储用户记录的页在页34和页35中

3. 在真实存储用户记录的页中定位到具体的记录

   到页34和页35中定位到具体的记录.

4. 但这个B+树的叶子节点中的记录只存储了c2和c1(主键)两个列, 所以我们必须在根据主键值去聚簇索引中再查找一遍完整的用户记录. 

**概念：回表** 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 `聚簇索引` 中再查一遍，这个过程称为 `回表` 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

**问题：**为什么我们还需要一次 `回表 `操作呢？直接把完整的用户记录放到叶子节点不OK吗？

回答: 如果把完整的用户记录放到叶子节点是可以不用回表, 但是太占空间, 相当于每建一棵B+树, 都需要把所有的用户记录都在拷贝一遍, 这就有点太浪费存储空间了. 

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录, 所以这种B+树也被称为二级索引(secondary index) 或辅助索引. 由于我们使用的是c2列的大小作为B+树的排序规则, 所以我们也称这个B+树是为c2列建立的索引.

非聚簇索引的存在, 不影响数据在聚簇索引中的组织, 所以一张表可以有多个非聚簇索引. 



![image-20220208161538574](pic/image-20220208161538574.png)

3. 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序。

- 在记录的c2列相同的情况下，采用c3列进行排序

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

建立 联合索引 只会建立如上图一样的1棵B+树。

为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

3.4 InnoDB**的**B+**树索引的注意事项** 

\1. **根页面位置万年不动** 

\2. **内节点中目录项记录的唯一性** 

\3. **一个页面最少存储**2**条记录** 